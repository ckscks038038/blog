<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Tree | Lutein 40g</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/blog/tags/tree/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css" integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/blog/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/blog/tags/tree/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blog/tags/tree/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/blog/" accesskey="h" title="Lutein 40g (Alt + H)">Lutein 40g</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/blog/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Tree
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>51. N-Queens 
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 在完成這題之前看了很多影片教學，下述幾個影片是我覺得對理解backtracking非常有幫助的：
印度老哥圖解方法，用tree來呈現整個回溯過程 這次官神的解法比neetcode更好理解 題目： * Example 1: * Example 2: * Example 3: 解題思路： 1. 2. 程式碼： </p>
  </div>
  <footer class="entry-footer">May 30, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 51. N-Queens " href="http://localhost:1313/blog/post/leetcode_51/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>17. Letter Combinations of a Phone Number
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題應該是backtracking寫到現在最簡單的一題，不需要考慮pop()，只管把所有可能列出來即可。
題目： Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
解題思路： 看著圖片，把所有可能按照給的digits依序append()到curStr即可
唯一需要注意的是，如果遇到空字串digits = &#34;&#34;，需要return 的是空list[]，但進入迴圈的話會在一開始就append一個&#34;&#34;
為了避免此問題要先判斷digits是否為空字串
程式碼： class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: res = [] map = { &#34;2&#34;:&#34;abc&#34;, &#34;3&#34;:&#34;def&#34;, &#34;4&#34;:&#34;ghi&#34;, &#34;5&#34;:&#34;jkl&#34;, &#34;6&#34;:&#34;mno&#34;, &#34;7&#34;:&#34;pqrs&#34;, &#34;8&#34;:&#34;tuv&#34;, &#34;9&#34;:&#34;wxyz&#34;, } def dfs(curStr, i): if i &gt;= len(digits): res....</p>
  </div>
  <footer class="entry-footer">May 24, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 17. Letter Combinations of a Phone Number" href="http://localhost:1313/blog/post/leetcode_17/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>79. Word Search
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題也是經典backtracking套路，可以分層理解。假設大目標是ABCD，那找到A以後，目標變成找BCD，一直延續下去。
題目： Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
* Example 1: Input: board = [[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;,&#34;E&#34;], [&#34;S&#34;,&#34;F&#34;,&#34;C&#34;,&#34;S&#34;], [&#34;A&#34;,&#34;D&#34;,&#34;E&#34;,&#34;E&#34;]], word = &#34;ABCCED&#34; Output: true * Example 2: Input: board = [[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;,&#34;E&#34;], [&#34;S&#34;,&#34;F&#34;,&#34;C&#34;,&#34;S&#34;], [&#34;A&#34;,&#34;D&#34;,&#34;E&#34;,&#34;E&#34;]], word = &#34;SEE&#34; Output: true * Example 3: 解題思路： 兩個核心概念，邊界條件以及bfs機制。...</p>
  </div>
  <footer class="entry-footer">May 23, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 79. Word Search" href="http://localhost:1313/blog/post/leetcode_79/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>131. Palindrome Partitioning
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 一開始看很難，但其實是很典型的backtracking套路，不要想一次把整個遞迴結構想出來，應該以單層的角度，把下面子問題抽象來看。
題目： Given a string s, partition s such that every substring of the partition is a palindrome . Return all possible palindrome partitioning of s.
* Example 1: Input: s = &#34;aab&#34; Output: [[&#34;a&#34;,&#34;a&#34;,&#34;b&#34;],[&#34;aa&#34;,&#34;b&#34;]] * Example 2: Input: s = &#34;a&#34; Output: [[&#34;a&#34;]] 解題思路： 這題也是決策樹問題，把圖畫出來如上。
1. 第一部份 字串aab在進入for迴圈可以將整個字串s切成兩一部份。
第一部份又可以分為三種可能：
i: 0 -&gt; 0: &#34;a&#34; i: 0 -&gt; 1: &#34;aa&#34; i: 0 -&gt; 2: &#34;aab&#34; 接著判斷是否第一部份為回文，是的話進入第二部份，並且將子字串加入part; 不是的話則不繼續往下找
for j in range(i, len(s)): if self....</p>
  </div>
  <footer class="entry-footer">May 22, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 131. Palindrome Partitioning" href="http://localhost:1313/blog/post/leetcode_131/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>40. Combination Sum II
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題跟剛剛做完的90. Subsets II 解法幾乎完全一樣，只差了這次需要考慮total，但值得注意的是，兩個題目是完全不同的呈現，所以有時仔細思考後，會發現不同問題其實本質是一致的。
另外，這次neetcode是用for迴圈解，我現在覺得決策樹問題用dfs思考會比較直觀，所以就用了底下留言給的程式碼做參考。
題目： Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.
Each number in candidates may only be used once in the combination.
Note: The solution set must not contain duplicate combinations.
* Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8 Output: [ [1,1,6], [1,2,5], [1,7], [2,6] ] * Example 2: Input: candidates = [2,5,2,1,2], target = 5 Output: [ [1,2,2], [5] ] 解題思路： 1....</p>
  </div>
  <footer class="entry-footer">May 19, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 40. Combination Sum II" href="http://localhost:1313/blog/post/leetcode_40/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>90. Subsets II
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題跟78. Subsets 是幾乎一樣的問題，唯一的差別是這題給的input nums會有重複元素出現，但是output res不可有重複組合。
題目： Given an integer array nums that may contain duplicates, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
* Example 1: Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] * Example 2: Input: nums = [0] Output: [[],[0]] 解題思路： 一樣用決策樹的思路，一邊是放入當前元素、另一邊是不放入當前元素，只是放入如果已經放入了nums[i](#1)，在pop()後並且跳過nums[i]，打算在下次考慮nums[i&#43;1]前，要先判斷目前的nums[i]與nums[i&#43;1]是否一樣，如果一樣的話就跳過。這樣才可避免走到跟 #1 一樣的決策情況。
一樣，決策的題目畫出決策樹是最好理解的。
程式碼： class Solution: def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: res = [] nums....</p>
  </div>
  <footer class="entry-footer">May 19, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 90. Subsets II" href="http://localhost:1313/blog/post/leetcode_90/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>46. Permutations
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題看neetcode的作法感覺像是逆序而行，不太直觀，目前為止還沒看懂。先以之前寫過的解法來做題，下次再做到這題再用neetcode的解法試試。
題目： Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
* Example 1: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] * Example 2: Input: nums = [0,1] Output: [[0,1],[1,0]] * Example 3: Input: nums = [1] Output: [[1]] 解題思路： 假設一開始組合為空，那就是用for迴圈考慮當前的所有選擇，進入每個選擇時都先將當前的元素加入組合中，並且把當前數字移除，使得之後可以考慮的數字剩下除了剛剛加入的元素之外的所有元素，接著再重新進入下一個迴圈
1. Base case 當目前組合的長度已經等於原本nums的長度，則表示已經選完所有數字，即將當前組合append到res中
程式碼： class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: res = [] comb = [] n = len(nums) def backtracking(nums): if len(comb) == n: res....</p>
  </div>
  <footer class="entry-footer">May 19, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 46. Permutations" href="http://localhost:1313/blog/post/leetcode_46/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>39. Combination Sum 
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題的決策樹(decision tree)比較比較特別，左邊代表繼續選原本的，右邊代表啥都不選，就給你空著。只要把這個概念想清楚，這題也就迎刃而解了。
題目： Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different....</p>
  </div>
  <footer class="entry-footer">May 19, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 39. Combination Sum " href="http://localhost:1313/blog/post/leetcode_39/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>297. Serialize and Deserialize Binary Tree
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題用DFS或BFS來做serialize跟deserialize，但因為DFS比較容易想，code也比較少，就選擇用DFS來寫。
題目： Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure....</p>
  </div>
  <footer class="entry-footer">May 17, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 297. Serialize and Deserialize Binary Tree" href="http://localhost:1313/blog/post/leetcode_297/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>124. Binary Tree Maximum Path Sum
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題雖然是hard，但看完山景城跟neetcode的解釋後便頓然開悟，比起前幾題，124反而在解題方向上更明確。 做完這題應該要去做leetcode_543，解題思路幾乎相同。
題目： A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node’s values in the path.
Given the root of a binary tree, return the maximum path sum of any non-empty path....</p>
  </div>
  <footer class="entry-footer">May 17, 2023&amp;nbsp;·&amp;nbsp;Yang</footer>
  <a class="entry-link" aria-label="post link to 124. Binary Tree Maximum Path Sum" href="http://localhost:1313/blog/post/leetcode_124/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://localhost:1313/blog/tags/tree/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/blog/">Lutein 40g</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
